---
description: PostgreSQL database conventions
globs: ["**/migrations/**", "**/db/**", "**/*.sql"]
---

# Database Conventions

## Connection
- Use async `psycopg` with connection pool
- Pool managed in `automation_backend/db/pool.py`
- Pattern:
  ```python
  async with pool.connection() as conn:
      async with conn.cursor() as cur:
          await cur.execute(query, params)
  ```

## Migrations

### Location
- `automation-backend/src/automation_backend/migrations/`

### Naming
- Sequential numbered: `001_initial_schema.sql`, `002_indexes.sql`
- Python migrations for complex logic: `017_generate_recipe_images.py`

### Structure
```sql
-- 0XX_description.sql
-- Description of what this migration does

CREATE TABLE IF NOT EXISTS table_name (
    id SERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add indexes
CREATE INDEX IF NOT EXISTS idx_name ON table_name (column);
```

### Best Practices
- Use `IF NOT EXISTS` / `IF EXISTS` for idempotency
- Add indexes in separate migration or same file
- Document purpose in comment header
- Test migrations on fresh database

## Query Patterns

### Parameterized Queries
```python
# Always use parameterized queries
await cur.execute(
    "SELECT * FROM recipes WHERE id = %s",
    (recipe_id,)
)
```

### Returning Data
```python
# Use RETURNING for inserts/updates
await cur.execute(
    "INSERT INTO items (name) VALUES (%s) RETURNING id",
    (name,)
)
row = await cur.fetchone()
```

## Schema Design
- Use SERIAL or BIGSERIAL for IDs
- Use TIMESTAMPTZ for timestamps
- Add foreign key constraints
- Use appropriate indexes for query patterns
